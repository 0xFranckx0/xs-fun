=head1 Basic XS

XS allows us to embed C code directly in the XS file. Hence, it doesn't need
to be in a completely separate library. We can therefore write functions in
C that will help us speed up our code. If we have a function that needs
intensive calculation, moving that to C will give us much more speed.

=head2 Basic functions

Let's add a function to our XS code.  Create a new directory for this
project and copy across the skeleton C<XSFun.xs>, C<Makefile.PL> and
C<ppport.h> files from our initial template directory.

Open the C<XSFun.xs> file and copy the following after the I<XS code>
comment:

    double
    add_numbers(double a, double b)
        CODE:
           RETVAL = a + b;
        OUTPUT:
           RETVAL

We define a function called C<add_numbers>. It takes two numbers of type
I<double> and as you can see by the definition, it also returns a I<double>
type.

We have a I<CODE> section which sets the return value (I<RETVAL>) to the sum
of I<a> and I<b>. We also have an I<OUTPUT> section that indicates the output
is the return value (I<RETVAL>).

=head2 A touch of Perl API

Instead of working with pure C types, we can use Perl types. We can write a
function that receives pointers to two SVs (Scalar Values) and returns an SV
pointer to the result. We will create a new SV to represent the value and
return a pointer to that.

    SV *
    add_numbers_perl(SV *a, SV *b)
        CODE:
        {
            const double sum = SvNV(a) + SvNV(b);
            RETVAL = newSVnv(sum);
        }
        OUTPUT: RETVAL

=head2 Building the project

We're now in a position to build the project and compile the library.  As
with many Perl modules one creates the C<Makefile> by running

    perl Makefile.PL

after which we merely need to run

    make

and our library is available within the C<blib> directory.

Note that if you're using Strawberry Perl on Windows, use C<dmake> instead
of C<make>.


As soon as we compile our code, the function will be available to the
B<XSFun> package and be callable as C<XSFun::add_numbers>.  However, in case
we want users to call it as simply C<add_numbers>, we need to export it.

Open F<lib/XSFun.pm> and fix the C<%EXPORT_TAGS> variable to include this new
function:
=head2 Exporting our functions

    our %EXPORT_TAGS = ( 'all' => [qw<add_numbers add_numbers_perl>] );

=head2 Testing

Let's write a small test script that shows off our spectacular code. Create
a directory F<t> and inside it create the following file F<add_numbers.t>:

    #!perl
    use strict;
    use warnings;

    use Test::More tests => 9;

    use_ok( 'XSFun', ':all' );

    # testing integers
    is( add_numbers(  5, 3 ),  8, '5 + 3 = 8'   );
    is( add_numbers( 31, 1 ), 32, '31 + 1 = 32' );

    is( add_numbers_perl(  5, 3 ),  8, '5 + 3 = 8'   );
    is( add_numbers_perl( 31, 1 ), 32, '31 + 1 = 32' );

    # testing fractions
    is( add_numbers( 3.1, 4.2 ), 7.3, '3.1 + 4.2 = 7.3' );
    is( add_numbers( 3.2, 4.3 ), 7.5, '3.2 + 4.3 = 7.5' );

    is( add_numbers_perl( 3.1, 4.2 ), 7.3, '3.1 + 4.2 = 7.3' );
    is( add_numbers_perl( 3.2, 4.3 ), 7.5, '3.2 + 4.3 = 7.5' );

Now let's run the tests:

    perl Makefile.PL && make && make test

You can also run the following command to clean up your directory:

    make distclean

(if you're using Strawberry Perl on Windows, use C<dmake> instead of C<make>)

I<Why use C<Test::More::is> instead of C<Test::More::cmp_ok>?>

Usually we would use L<Test::More>'s C<cmp_ok()> to test numerical values, but
in this case we picked C<is()>. The reason is that the result we get back from
our function has a different absolute value from the one we check for in the
function, because of how Perl stores floating point values.

We can use C<sprintf()> to show the differences:

    $ perl -e 'printf "%.40f\n", $_ for 3.1+4.2, 7.3'
    7.3000000000000007105427357601001858711243
    7.2999999999999998223643160599749535322189

